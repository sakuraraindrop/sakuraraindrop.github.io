<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BH25-USA-HTTP1.1-Must-Die | cheng_xing's blog</title><meta name="robots" content="noindex"><meta name="author" content="cheng_xing"><meta name="copyright" content="cheng_xing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Abstract上游的 HTTP&#x2F;1.1 本质上是不安全的，并且经常使数百万网站面临恶意接管的风险。六年来的尝试性缓解措施掩盖了这个问题，但未能解决它。本文介绍了几种新型的 HTTP 同步失效攻击，可以大规模获取用户凭证。通过详细的案例研究展示了这些技术，包括通过破坏 Akamai、Cloudflare 和 Netlify 核心基础设施而暴露数千万网站的关键漏洞。我还介绍了一个开源工具包">
<meta property="og:type" content="article">
<meta property="og:title" content="BH25-USA-HTTP1.1-Must-Die">
<meta property="og:url" content="https://sakuraraindrop.github.io/2025/12/23/BH25-USA-HTTP1-1-Must-Die/index.html">
<meta property="og:site_name" content="cheng_xing&#39;s blog">
<meta property="og:description" content="Abstract上游的 HTTP&#x2F;1.1 本质上是不安全的，并且经常使数百万网站面临恶意接管的风险。六年来的尝试性缓解措施掩盖了这个问题，但未能解决它。本文介绍了几种新型的 HTTP 同步失效攻击，可以大规模获取用户凭证。通过详细的案例研究展示了这些技术，包括通过破坏 Akamai、Cloudflare 和 Netlify 核心基础设施而暴露数千万网站的关键漏洞。我还介绍了一个开源工具包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sakuraraindrop.github.io/img/ltx.jpg">
<meta property="article:published_time" content="2025-12-23T11:20:15.000Z">
<meta property="article:modified_time" content="2025-12-28T08:40:17.433Z">
<meta property="article:author" content="cheng_xing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sakuraraindrop.github.io/img/ltx.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "BH25-USA-HTTP1.1-Must-Die",
  "url": "https://sakuraraindrop.github.io/2025/12/23/BH25-USA-HTTP1-1-Must-Die/",
  "image": "https://sakuraraindrop.github.io/img/ltx.jpg",
  "datePublished": "2025-12-23T11:20:15.000Z",
  "dateModified": "2025-12-28T08:40:17.433Z",
  "author": [
    {
      "@type": "Person",
      "name": "cheng_xing",
      "url": "https://sakuraraindrop.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/ltx-icon.jpg"><link rel="canonical" href="https://sakuraraindrop.github.io/2025/12/23/BH25-USA-HTTP1-1-Must-Die/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BH25-USA-HTTP1.1-Must-Die',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/hk.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/ltx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">163</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/hk.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/ltx-icon.jpg" alt="Logo"><span class="site-name">cheng_xing's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">BH25-USA-HTTP1.1-Must-Die</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">BH25-USA-HTTP1.1-Must-Die</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-23T11:20:15.000Z" title="发表于 2025-12-23 19:20:15">2025-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-28T08:40:17.433Z" title="更新于 2025-12-28 16:40:17">2025-12-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/research/">research</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>上游的 HTTP&#x2F;1.1 本质上是不安全的，并且经常使数百万网站面临恶意接管的风险。六年来的尝试性缓解措施掩盖了这个问题，但未能解决它。本文介绍了几种新型的 HTTP 同步失效攻击，可以大规模获取用户凭证。通过详细的案例研究展示了这些技术，包括通过破坏 Akamai、Cloudflare 和 Netlify 核心基础设施而暴露数千万网站的关键漏洞。我还介绍了一个开源工具包，可以实现解析器差异和特定目标薄弱点的系统检测。结合使用，这个工具包和这些技术在两周内共产生了超过 20 万美元的漏洞赏金。归根结底，我认为必须将 HTTP 请求走私认定为一种根本性的协议缺陷。过去六年的经历表明，仅仅解决单独的实现问题永远无法消除这一威胁。尽管我的发现已经被报告并修补，网站仍然在默默地暴露于不可避免的未来变种风险之中。这一切都源于 HTTP&#x2F;1.1 的一个致命缺陷，这意味着小的实现漏洞经常会引发严重的安全后果。HTTP&#x2F;2 解决了这一威胁。如果我们想要一个安全的网络，HTTP&#x2F;1.1 必须淘汰。</p>
<h2 id="The-desync-endgame"><a href="#The-desync-endgame" class="headerlink" title="The desync endgame"></a>The desync endgame</h2><h3 id="The-fatal-flaw-in-HTTP-1-1"><a href="#The-fatal-flaw-in-HTTP-1-1" class="headerlink" title="The fatal flaw in HTTP&#x2F;1.1"></a>The fatal flaw in HTTP&#x2F;1.1</h3><p>HTTP&#x2F;1.1 存在一个致命且高度可利用的漏洞 —— 单个 HTTP 请求之间的边界非常脆弱。请求在底层 TCP&#x2F;TLS 套接字上只是简单地串联在一起，没有分隔符，而且有多种方式可以指定它们的长度。这意味着攻击者可以制造关于一个请求何时结束、下一个请求何时开始的极端模糊性。大型网站通常使用反向代理，将不同用户的请求通过共享连接池传递到后端服务器。这意味着攻击者如果在服务器链中发现最微小的解析器差异，就可以导致不同步，在其他用户的请求中应用恶意前缀，并通常实现对整个网站的完全接管：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/1.png" alt="alt text"></p>
<p>由于 HTTP&#x2F;1.1 是一种古老的、宽松的、基于文本的协议，并且有数千种实现，找到解析器差异并不难。2019 年我首次发现这一威胁时，感觉几乎可以入侵任何东西。例如，<a target="_blank" rel="noopener" href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn#paypal">我展示了它可以被利用来入侵 PayPal 的登录页面</a>，且我做了两次。此后，<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling">我们还发布了一个关于请求走私的免费在线课程</a>，以及多篇<a target="_blank" rel="noopener" href="https://portswigger.net/research/request-smuggling">进一步的研究论文</a>。如果你在后面的技术细节中迷失，回头参考这些资料可能会很有帮助。</p>
<p>六年后，很容易认为我们已经解决了这个问题，通过解析器的收紧和 HTTP&#x2F;2——一种二进制协议，如果用于从前端开始的上行连接，几乎可以消除整个攻击类别。不幸的是，事实证明，我们所做的只不过是让问题看起来像是解决了。</p>
<h3 id="Mitigations-that-hide-but-don’t-fix"><a href="#Mitigations-that-hide-but-don’t-fix" class="headerlink" title="Mitigations that hide but don’t fix"></a>Mitigations that hide but don’t fix</h3><p>在2025年，HTTP&#x2F;1.1无处不在——但不一定显而易见。服务器和CDN经常声称支持HTTP&#x2F;2，但实际上会将传入的HTTP&#x2F;2请求降级为HTTP&#x2F;1.1，以便传输到后端系统，从而失去了大部分安全优势。将传入的HTTP&#x2F;2消息降级比端到端使用HTTP&#x2F;1.1还要危险，因为它引入了第四种指定消息长度的方式。在本文中，我们将使用以下缩写来表示四种主要的长度解释方式：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/2.png" alt="alt text"></p>
<p>HTTP&#x2F;1.1 乍一看可能看起来很安全，因为如果你使用原始的请求走私方法和工具包，你很难造成不同步。但这是为什么呢？让我们来看一个使用轻度混淆的 Transfer-Encoding 头的经典 CL.TE 攻击。在此攻击中，我们希望前端服务器使用 Content-Length 头解析请求，然后将请求转发到后端，而后端则使用 Transfer-Encoding 头计算长度。</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/3.png" alt="alt text"></p>
<p>这是模拟受害者：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/4.png" alt="alt text"></p>
<p>这曾经可以在大量网站上使用。如今，即使你的目标实际上存在漏洞，探测也可能失败，原因可能是以下三种之一：</p>
<ul>
<li>WAF 现在使用正则表达式来检测和阻止带有混淆传输编码头或请求体中潜在 HTTP 请求的请求。</li>
<li>&#x2F;robots.txt 检测工具在你的特定目标上无法工作。</li>
<li>存在服务器端竞争条件，这使得该技术在某些目标上非常不可靠。</li>
</ul>
<p>我之前研究中讨论的基于超时的替代检测策略也被广泛指纹识别并被 WAF 阻止。这就导致了不同步的最终局面——你会因为一些玩具式的缓解措施和选择性加固而产生安全的错觉，而这些措施实际上只是破坏了既定的检测方法。一切看似安全，直到你做出哪怕是最微小的修改。事实上，HTTP&#x2F;1.1 的实现中充斥着大量关键漏洞，你甚至可能在无意中就发现它们。</p>
<h3 id="Hacking-20-million-websites-by-accident"><a href="#Hacking-20-million-websites-by-accident" class="headerlink" title="Hacking 20 million websites by accident"></a>Hacking 20 million websites by accident</h3><p>HTTP&#x2F;1.1 根本不适合一个我们通过增加另一层来解决每个问题的世界。以下案例研究对此有很好的说明。Wannes Verwimp4 向我征求了对他发现的一个问题的看法，该问题影响了一个托管在 Heroku 且在 Cloudflare 背后的站点。他发现了一个 H2.0 不同步问题，并能够利用它将访问者重定向到他自己的网站。</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/5.png" alt="alt text"></p>
<p>这个重定向被保存在 Cloudflare 的缓存中，所以通过污染一个 JavaScript 文件的缓存条目，他能够持久地控制整个网站。这一切原本无甚特别，除了有一件事——被劫持的用户并不是试图访问目标网站。事实上，这次攻击是在入侵随机的第三方网站，包括某些银行！</p>
<p>我同意进行调查，并注意到另一件奇怪的事情——这次攻击被 Cloudflare 的前端缓存拦截了，这意味着请求根本不会到达后端服务器。我推测这次攻击不可能成功，而且 Wannes 一定是搞错了，于是我添加了一个缓存破坏器……结果攻击失败了。当我移除缓存破坏器时，攻击又开始生效了。</p>
<p>忽略攻击被缓存阻挡的事实后，Wannes 发现了 Cloudflare 基础设施内部的一个 HTTP&#x2F;1.1 不同步问题：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/6.png" alt="alt text"></p>
<p>这一发现使超过2400万个网站面临完全接管的风险！它体现了不同步攻击的终极形态——经典方法已经不起作用，但基于HTTP&#x2F;1构建的系统如此复杂且关键，你只要犯一个错误，就可能控制2400万个网站。我们报告了这个问题，Cloudflare在数小时内进行了修补，发布了<a target="_blank" rel="noopener" href="https://blog.cloudflare.com/resolving-a-request-smuggling-vulnerability-in-pingora/">事后分析</a>，并奖励了7000美元的奖金。</p>
<p>不熟悉漏洞赏金猎人的读者可能会发现，在整篇白皮书中，赏金支付的金额相对于漏洞影响常常让人感到惊讶，但大多数获得的赏金接近各自项目所宣传的最高支付金额。赏金的大小是底层经济情况的产物，任何真正令人意外的赏金经历将会被特别指出。</p>
<h3 id="“HTTP-1-is-simple”-and-other-lies"><a href="#“HTTP-1-is-simple”-and-other-lies" class="headerlink" title="“HTTP&#x2F;1 is simple” and other lies"></a>“HTTP&#x2F;1 is simple” and other lies</h3><p>这种漏洞是怎么发生的？部分原因是所涉及系统的极其复杂。例如，我们可以推测，发送到 Cloudflare 的 HTTP&#x2F;2 请求有时会被改写为内部使用的 HTTP&#x2F;1.1，然后再改写回用于上游连接的 HTTP&#x2F;2！然而，根本问题在于基础架构。</p>
<p>有一种普遍且危险的误解认为 HTTP&#x2F;1.1 是一个坚固的基础，适用于你可能构建的任何系统。特别是，那些没有实现过反向代理的人常常认为 HTTP&#x2F;1.1 很简单，因此很安全。但一旦你尝试代理 HTTP&#x2F;1.1，它就变得远不那么简单了。为了说明这一点，以下是我个人曾经相信的五个谎言，每一个在本文后面讨论的真实世界漏洞中都将至关重要。</p>
<ul>
<li>Lie1：HTTP&#x2F;1.1 请求不能直接针对中间节点</li>
<li>Lie2：HTTP&#x2F;1.1 不同步只能由解析器差异引起</li>
<li>Lie3：一个 HTTP&#x2F;1.1 响应包含代理解析所需的一切</li>
<li>Lie4：一个 HTTP&#x2F;1.1 响应只能包含一个头部块</li>
<li>Lie5：完整的 HTTP&#x2F;1.1 响应需要一个完整的请求</li>
</ul>
<p>你相信了哪些？你能将每个陈述对应到破坏它的特征吗？综观而言，最后三个谎言背后的现实是：你的代理需要一个对请求对象的引用，仅仅为了从后端的 TCP 套接字中读取正确数量的响应字节；你需要控制流分支来处理多个头块，即使你甚至还没到达响应主体；整个响应可能在客户端甚至还没完成发送请求之前就已经到达了。</p>
<p>这是 HTTP&#x2F;1.1——它是网络的基础，充满了复杂性和陷阱，经常让数以百万计的网站暴露风险，而我们已经花了六年的时间却未能修补实现以弥补这些问题。它需要被淘汰。为了实现这一点，我们需要共同向世界展示 HTTP&#x2F;1.1 是不安全的——特别是，更多的不同步攻击总是即将到来。在本文的其余部分，我希望向你展示如何做到这一点。</p>
<p>所有案例研究都是通过对拥有漏洞披露计划（VDP）的目标进行授权测试而确定的，并且已被私下报告和修复（除非另有说明）。由于VDP条款和条件的副作用，其中许多信息被部分涂黑，即使问题实际上已经修复。当公司被明确命名时，这表明他们拥有更成熟的安全计划。在这项研究中获得的所有奖金都在参与者之间平均分配，我的那部分奖金随后被PortSwigger加倍，并捐赠给了当地的慈善机构。</p>
<h2 id="A-strategy-to-win-the-desync-endgame"><a href="#A-strategy-to-win-the-desync-endgame" class="headerlink" title="A strategy to win the desync endgame"></a>A strategy to win the desync endgame</h2><h3 id="Detecting-parser-discrepancies"><a href="#Detecting-parser-discrepancies" class="headerlink" title="Detecting parser discrepancies"></a>Detecting parser discrepancies</h3><p>在 desync 终局中，由于缓解措施、复杂性和特殊情况，检测漏洞非常困难。要在这种环境中取得成功，我们需要一种检测策略，能够可靠地识别使 desync 攻击成为可能的潜在缺陷，而不是尝试那些涉及许多环节的脆弱攻击。这将帮助我们识别并克服利用挑战。早在 2021 年，Daniel Thacher 在 Black Hat Europe 上展示了<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=RAtpG6OYYNM">《Practical HTTP Header Smuggling》</a>，并描述了一种使用 Content-Length 头检测解析器差异的方法。我非常喜欢这个概念，在尝试了他的工具之后，我决定尝试从零开始构建自己的实现，稍微以不同的方式进行，并看看会发生什么。</p>
<p>这个工具被证明非常有效，我很高兴将其发布为开源的 Burp Suite 扩展 <a target="_blank" rel="noopener" href="https://github.com/PortSwigger/http-request-smuggler/">HTTP Request Smuggler v3.0</a>。以下是用于分析的三个关键元素的概述，以及可能的结果：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/7.png" alt="alt text"></p>
<h3 id="Understanding-V-H-and-H-V-discrepancies"><a href="#Understanding-V-H-and-H-V-discrepancies" class="headerlink" title="Understanding V-H and H-V discrepancies"></a>Understanding V-H and H-V discrepancies</h3><p>让我们来看看实际检测，以及如何解读它：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/8.png" alt="alt text"></p>
<p>在这里，HTTP 请求走私器检测到，发送带有部分隐藏的 Host 头的请求会导致一个独特的响应，而发送普通的 Host 头、完全省略该头，或发送任意掩码头都无法触发这种响应。这是服务器链中存在解析器差异的有力证据。如果我们假设存在前端和后端，有两种主要可能性：</p>
<ul>
<li>可见-隐藏 (V-H)：被掩码的 Host 头对前端可见，但对后端隐藏。</li>
<li>隐藏-可见 (H-V)：被掩码的 Host 头对前端隐藏，但对后端可见。</li>
</ul>
<p>你通常可以通过仔细观察响应来区分 V-H 和 H-V 不一致，并猜测它们是来自前端还是后端。请注意，具体的状态码并不重要，有时还会令人困惑。重要的是它们不同。事实证明，这是一个 V-H 不一致。</p>
<h3 id="Turning-a-V-H-discrepancy-into-a-CL-0-desync"><a href="#Turning-a-V-H-discrepancy-into-a-CL-0-desync" class="headerlink" title="Turning a V-H discrepancy into a CL.0 desync"></a>Turning a V-H discrepancy into a CL.0 desync</h3><p>在出现 V-H 差异时，你可以尝试通过从后端隐藏 Transfer-Encoding 头来进行 TE.CL 利用，或者通过隐藏 Content-Length 头来尝试 CL.0 利用。我强烈建议在可能的情况下使用 CL.0，因为它更不容易被 WAF 阻拦。在许多 V-H 目标上，包括上面提到的，利用都很简单：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/9.png" alt="alt text"></p>
<p>在另一个目标上，上述漏洞利用失败了，因为前端服务器拒绝包含请求体的 GET 请求。我能够通过将方法切换为 OPTIONS 来解决这个问题。正是这种发现并解决障碍的能力，使得扫描解析器差异非常有用。我没有在这个目标上花时间制作一个完全武器化的概念验证，因为对于低薪的赏金计划和漏洞披露计划来说，这并不经济。</p>
<h3 id="Detection-strategies"><a href="#Detection-strategies" class="headerlink" title="Detection strategies"></a>Detection strategies</h3><p>通过结合不同的头部、排列和策略，该工具实现了更优秀的覆盖率。例如，这里是使用相同的头部（Host）、相同的排列（在头部名称前添加空格），但不同策略（重复 Host 并使用无效值）所发现的内容：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/10.png" alt="alt text"></p>
<p>这个目标再次可以通过 CL.0 反同步轻松利用。根据我的经验，网络 VPN 通常存在 HTTP 实现缺陷，我强烈建议不要将它放在任何类型的反向代理后面。</p>
<h3 id="Detecting-high-risk-parsing"><a href="#Detecting-high-risk-parsing" class="headerlink" title="Detecting high-risk parsing"></a>Detecting high-risk parsing</h3><p>差异检测方法还可以识别那些偏离公认解析规范的服务器，因此如果将其放置在反向代理后面，可能容易受到攻击。例如，扫描一台 <redacted> 服务器时发现，他们并不将 <code>\n\n</code> 视为结束头部块：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/11.png" alt="alt text"></p>
<p>直接访问这是无害的，但 RFC-91129 规定“接收方可以将单个 LF 识别为行终止符”。在这样的前端下，这可能会被利用。这个漏洞被追溯到底层的 HTTP 库，并且修补程序正在开发中。报告像这样的理论性发现不太可能获得高额的漏洞赏金，但可能对提高整个生态系统的安全性有很大帮助。</p>
<h3 id="Exploiting-H-V-on-IIS-behind-ALB"><a href="#Exploiting-H-V-on-IIS-behind-ALB" class="headerlink" title="Exploiting H-V on IIS behind ALB"></a>Exploiting H-V on IIS behind ALB</h3><p>HTTP 请求走私器还发现了大量使用 Microsoft IIS 并部署在 AWS 应用负载均衡器（ALB）背后的易受攻击系统。理解这一点非常有用，因为 AWS 并不打算修补它。检测通常显示如下：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/12.png" alt="alt text"></p>
<p>正如你可以从服务器横幅中推断的，这是一个 H-V 差异：当格式错误的 Host 头被混淆时，ALB 无法识别它，并将请求传递到后端服务器。利用 H-V 差异的经典方法是使用 CL.TE 不同步攻击，因为 Transfer-Encoding 头通常优先于 Content-Length，但这会被 AWS 的 Desync Guardian 阻止。我决定先搁置这个问题，专注于其他发现，然后 <a target="_blank" rel="noopener" href="https://www.assured.se/posts/the-single-packet-shovel-desync-powered-request-tunnelling">Thomas Stacey 独立发现了它</a>，并使用 H2.TE 不同步绕过了 Desync Guardian。即使 H2.TE 绕过被修复，攻击者仍然可以利用这一点走私请求头，从而实现 IP 欺骗，有时甚至能<a target="_blank" rel="noopener" href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn#explore">完全绕过身份验证</a>。</p>
<p>我向 AWS 报告了这个问题，结果发现他们早已知晓，但选择不修补，因为他们不想破坏与发送格式错误请求的旧 HTTP&#x2F;1 客户端的兼容性。你可以自己通过更改两个设置来修补它：</p>
<ul>
<li>设置 routing.http.drop_invalid_header_fields.enabled</li>
<li>设置 routing.http.desync_mitigation_mode &#x3D; strictest<br>这个未修复的问题暴露了云代理一个被忽视的危险：采用它们会将其他公司的技术债务直接引入你自己的安全态势中。</li>
</ul>
<h3 id="Exploiting-H-V-without-Transfer-Encoding"><a href="#Exploiting-H-V-without-Transfer-Encoding" class="headerlink" title="Exploiting H-V without Transfer-Encoding"></a>Exploiting H-V without Transfer-Encoding</h3><p>这项研究的下一个重大突破是在我发现某个网站存在 H-V 差异时出现的，该网站会阻止所有包含 Transfer-Encoding 的请求，使 CL.TE 攻击变得不可能。对此，唯一的解决方法就是进行 0.CL 不同步攻击。</p>
<h2 id="0-CL-desync-attacks"><a href="#0-CL-desync-attacks" class="headerlink" title="0.CL desync attacks"></a>0.CL desync attacks</h2><h3 id="The-0-CL-deadlock"><a href="#The-0-CL-deadlock" class="headerlink" title="The 0.CL deadlock"></a>The 0.CL deadlock</h3><p>0.CL 反同步攻击被广泛认为无法被利用。要理解原因，可以考虑当你向具有 H-V 解析器差异的目标发送以下攻击时会发生什么：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/13.png" alt="alt text"></p>
<p>前端看不到 Content-Length 头，因此它会将橙色负载当作第二个请求的开始。这意味着它会缓存橙色负载，并且只将头部块转发到后端：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/14.png" alt="alt text"></p>
<p>后端确实会看到 Content-Length 头，因此它会等待请求体的到达。与此同时，前端会等待后端的回复。最终，其中一个服务器会超时并重置连接，从而中断攻击。本质上，0.CL 不同步攻击通常会导致上游连接死锁。</p>
<h3 id="Breaking-the-0-CL-deadlock"><a href="#Breaking-the-0-CL-deadlock" class="headerlink" title="Breaking the 0.CL deadlock"></a>Breaking the 0.CL deadlock</h3><p>在这项研究之前，我花了两年时间研究竞争条件和时序攻击。在这个过程中，我偶然发现了0.CL死锁的一个解决方案。每当我尝试对运行nginx的目标上的静态文件使用<a target="_blank" rel="noopener" href="https://portswigger.net/research/the-single-packet-attack-making-remote-race-conditions-local">单包攻击</a>时，nginx都会在请求完成之前响应，从而破坏了我的时序测量。这当时需要一个复杂的变通办法，但也暗示了使0.CL可被利用的方法。</p>
<p>打破 0.CL 死锁的关键是找到一个早期响应的小工具：一种在请求主体到达之前就让后端服务器响应请求的方法。这在 nginx 上很简单，但我的目标是运行 IIS，而静态文件技巧在那儿不起作用。那么，我们如何说服 IIS 在请求主体到达之前就响应请求呢？让我们来看一下我最喜欢的 Windows 文档片段：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/15.png" alt="alt text"></p>
<p>如果你尝试使用保留名称访问文件或文件夹，操作系统会因为一些有趣的历史原因抛出异常。我们可以通过在映射到文件系统的任何文件夹中请求 ‘con’ 来让服务器触发这个特殊情况。</p>
<p>我发现如果我在目标网站上发送 <code>/con</code>，IIS 会在不等待请求体到达的情况下响应，而且会顺便保持连接打开。当与 CL.0 desync 配合使用时，这会导致它将第二个请求的开头解释为第一个请求的请求体，从而触发 400 Bad Request 响应。这是从用户视角看到的情况：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/16.png" alt="alt text"></p>
<p>以及后端连接视角看到的情况：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/17.png" alt="alt text"></p>
<p>我已经知道 <code>/con</code> 的特殊用法十多年了，但这是我第一次真正能够利用它！此外，在过去的六年里，我看到过许多可疑的“错误请求”响应，我甚至让 HTTP Request Smuggler 用神秘标题 <a target="_blank" rel="noopener" href="https://github.com/PortSwigger/http-request-smuggler/blob/a05163d42989c07ff24bcd9e81e6e2d3c70ec966/src/burp/ImplicitZeroScan.java#L137">Mystery 400</a> 来报告它们。就在那一刻，我意识到它们很可能都是可被利用的。在其他服务器上，我发现服务器级的重定向可以作为早期响应小工具。然而，我从未找到适用于 Apache 的可行小工具；当遇到错误情况时，它们太仔细地关闭连接了。</p>
<h3 id="Moving-beyond-400-Bad-Request"><a href="#Moving-beyond-400-Bad-Request" class="headerlink" title="Moving beyond 400 Bad Request"></a>Moving beyond 400 Bad Request</h3><p>要证明你已经发现了 0.CL 的不同步，下一步是触发可控的响应。在攻击请求之后，发送一个包含嵌套在头部块中的第二个路径的“受害者”请求：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/18.png" alt="alt text"></p>
<p>如果你正确设置了第一个请求的 Content-Length，它会从受害者的请求中截取最初的字节，你会看到一个响应，表明隐藏的请求行已被处理。这足以证明存在 0.CL 反序列化问题，但显然这不是一个现实的攻击——我们不能假设受害者会在他们自己的请求中包含有效载荷！我们需要一种方法将我们的有效载荷添加到受害者的请求中。我们需要将我们的 0.CL 转换为 CL.0。</p>
<h3 id="Converting-0-CL-into-CL-0-with-a-double-desync"><a href="#Converting-0-CL-into-CL-0-with-a-double-desync" class="headerlink" title="Converting 0.CL into CL.0 with a double-desync"></a>Converting 0.CL into CL.0 with a double-desync</h3><p>要将 0.CL 转换成 CL.0，我们需要一次双重不同步！这是一种多阶段攻击，攻击者使用两个请求的序列来为受害者设置陷阱：</p>
<ul>
<li>第一个请求会导致连接与 0.CL 不同步</li>
<li>被污染的连接将第二个请求转换为 CL.0 不同步，然后用恶意前缀重新污染连接</li>
<li>恶意前缀随后会污染受害者的请求，导致有害的响应</li>
</ul>
<p>实现这一点最干净的方法是让 0.CL 在第一次请求时切掉整个头部块：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/19.png" alt="alt text"></p>
<p>不幸的是，这并不像看起来那么简单。你需要知道第二个请求头块的确切大小，而且实际上几乎所有前端服务器都会添加额外的头。在后端，上述请求序列最终看起来像这样：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/20.png" alt="alt text"></p>
<p>您可以使用 Turbo Intruder 的<a target="_blank" rel="noopener" href="https://github.com/PortSwigger/turbo-intruder/blob/master/resources/examples/0cl-find-offset.py">新 0cl-find-offset 脚本</a>来发现注入头的长度，但这些头部通常包含诸如客户端 IP 之类的信息，这意味着攻击对您有效，但当其他人尝试复制时会失败。这使得漏洞赏金的分类非常麻烦。</p>
<p>经过很多痛苦，我发现了一种更好的方法。大多数服务器会在头部块的末尾插入头，而不是在开始处插入。所以，如果我们走私的请求在那之前开始，攻击就会可靠地工作！这里有一个例子，使用输入反射来显示插入的头：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/21.png" alt="alt text"></p>
<p>从这一点开始，我们可以使用传统的 CL.0 利用技术。在这个目标上，我使用了 HEAD 技术向随机用户提供恶意 JavaScript：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/22.png" alt="alt text"></p>
<p>您可以使用我们的新网络安全学院<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/advanced/lab-request-smuggling-0cl-request-smuggling">实验 0.CL 请求走私</a>，免费亲自尝试这种技术。</p>
<p>使用这些技术，我们最初在拥有漏洞奖励计划的网站中发现了大约十个简单的0.CL漏洞。许多这些发现都出现在使用某种云WAF的网站上，这并不是我们第一次看到WAF使网站更容易被攻击。当时我们被其他发现分散了注意力，并没有将任何攻击武器化，除了DoS，因此总共获得的奖金仅为21,645美元。最好的奖金经历是来自EXNESS的，他们奖励了7,500美元。和往常一样，最有价值的结果不是奖金本身，而是这项工作为我们后续的发现奠定的基础。</p>
<h3 id="More-desync-attacks-are-coming"><a href="#More-desync-attacks-are-coming" class="headerlink" title="More desync attacks are coming"></a>More desync attacks are coming</h3><p>到这一点上，我认为 desync 威胁终于完全被绘制出来，未来的问题将是小众的、一次性的实现缺陷。这是我每年都会犯的一个错误。以下是请求走私方面重大进展的部分历史：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">2004年：HTTP请求走私</a> –（大多被遗忘）</li>
<li><a target="_blank" rel="noopener" href="https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf">2016：在 HTTP 中隐藏wookies</a>（当时大部分被忽视）</li>
<li><a target="_blank" rel="noopener" href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn">2019：利用头解析器差异</a>（CL.TE，TE.CL）</li>
<li><a target="_blank" rel="noopener" href="https://portswigger.net/research/http2">2021：利用 HTTP&#x2F;2 降级漏洞</a>（H2.CL，H2.TE）</li>
<li><a target="_blank" rel="noopener" href="https://portswigger.net/research/browser-powered-desync-attacks">2022：利用忽略 CL（CL.0、H2.0、CSD）的端点</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/">2024：利用 dechunking</a>（TE.0）</li>
<li><a target="_blank" rel="noopener" href="https://w4ke.info/2025/06/18/funky-chunks.html">2025：利用块扩展（TE.TE）</a></li>
<li>现在：0.CL 不同步攻击</li>
</ul>
<p>我直到下一个发现才最终意识到真相——更多的不同步攻击总是会到来。</p>
<h2 id="Expect-based-desync-attacks"><a href="#Expect-based-desync-attacks" class="headerlink" title="Expect-based desync attacks"></a>Expect-based desync attacks</h2><h3 id="The-Expect-complexity-bomb"><a href="#The-Expect-complexity-bomb" class="headerlink" title="The Expect complexity bomb"></a>The Expect complexity bomb</h3><p>早在2022年，我尝试过使用 Expect 头进行同步偏差攻击，但没有发现任何问题。事实证明，我当时没有仔细寻找。这一次，我首先在寻找一种在没有早期响应工具的情况下检测 0.CL 同步偏差漏洞的方法时，开始使用 Expect 头。</p>
<p>Expect 头是一个古老的优化机制，它将发送单个 HTTP 请求拆分为两个部分的过程。客户端发送包含 Expect: 100-continue 的头部块，服务器则评估该请求是否会被接受。如果服务器响应 HTTP&#x2F;1.1 100 Continue，客户端才被允许发送请求体。这对客户端和服务器来说都很复杂，对于反向代理来说更是严重。试想一下，如果前端不支持 Expect，或者没有看到该头部，或者把值解析为 100continue，会发生什么情况？后端又会怎样？如果后端提前响应，或者客户端没有等待 100-continue，会怎样？</p>
<p>第一个明确表明 Expect 头部与众不同的线索是，它在我的 Turbo Intruder 工具中的 HTTP 客户端出现了问题，这发生在一个关键点上，任何错误都可能导致不同步。修复客户端大大增加了代码的复杂性。这是之前从网络上读取响应的代码：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/23.png" alt="alt text"></p>
<p>之后：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/24.png" alt="alt text"></p>
<p>Expect 也会使服务器出现中断。在一个网站上，Expect 使服务器忘记了 HEAD 响应没有主体，并尝试从后端套接字读取过多数据，从而导致上游死锁：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/25.png" alt="alt text"></p>
<p>这很有趣，但相对无害——它只带来了拒绝服务（DoS）的风险。其他的不当行为就没那么无害了，例如多个服务器在响应 Expect 时会泄露内存。这显示出一些神秘的文本片段：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/26.png" alt="alt text"></p>
<p>以及密钥：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/27.png" alt="alt text"></p>
<h3 id="Bypassing-response-header-removal"><a href="#Bypassing-response-header-removal" class="headerlink" title="Bypassing response header removal"></a>Bypassing response header removal</h3><p>所有 HTTP&#x2F;1.1 响应都有一个头部块——除非你发送 Expect。因此，第二个头部块常常让解析器感到意外，并破坏前端服务器删除敏感响应头的尝试。以下是一个示例：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/28.png" alt="alt text"></p>
<p>我把这个例子报告给了 Netlify，他们说“这些信息是按设计提供的”。这种技术还揭示了数百个服务器&#x2F;版本横幅，这些横幅曾被人们试图隐藏，以减轻针对性的攻击。幸运的是，暴露的服务器横幅对合规性来说威胁更大，而不是对关键安全问题。</p>
<h3 id="An-unplanned-collaboration"><a href="#An-unplanned-collaboration" class="headerlink" title="An unplanned collaboration"></a>An unplanned collaboration</h3><p>大约在这个时候，我收到了来自一个专职赏金猎人小团队的消息——Paolo ‘sw33tLie’ Arnolfo、Guillermo ‘bsysop’ Gregorio 和 Mariani ‘Medusa’ Francesco。他们也注意到 Expect 头会引发一些有趣的情况。他们有着扎实的研究背景——<a target="_blank" rel="noopener" href="https://www.bugcrowd.com/blog/unveiling-te-0-http-request-smuggling-discovering-a-critical-vulnerability-in-thousands-of-google-cloud-websites/">他们对 TE.0 请求走私的探索</a>在 <a target="_blank" rel="noopener" href="https://portswigger.net/research/top-10-web-hacking-techniques-of-2024">2024 年十大网络攻击技术中排名第三</a>。因此，我们决定合作。最终，我们利用了许多目标。我们的发现大致可以分为四类：</p>
<h3 id="0-CL-desync-via-vanilla-Expect-T-Mobile"><a href="#0-CL-desync-via-vanilla-Expect-T-Mobile" class="headerlink" title="0.CL desync via vanilla Expect - T-Mobile"></a>0.CL desync via vanilla Expect - T-Mobile</h3><p>仅仅发送一个有效的 Expect 头就会在许多不同的服务器上引起 0.CL 同步失效。我认为这是前端服务器中 Expect 实现存在问题造成的，它会正确地转发头信息，但在遇到后端非 100 的响应时会感到困惑，并忘记它仍然需要从客户端接收请求体。</p>
<p>这是我们针对 T-Mobile 测试域构建的概念验证：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/29.png" alt="alt text"></p>
<p>T-Mobile 因这一漏洞向我们支付了 12,000 美元——这是针对非生产环境域名的高度竞争性奖金。</p>
<h3 id="0-CL-desync-via-obfuscated-Expect-Gitlab"><a href="#0-CL-desync-via-obfuscated-Expect-Gitlab" class="headerlink" title="0.CL desync via obfuscated Expect - Gitlab"></a>0.CL desync via obfuscated Expect - Gitlab</h3><p>发送轻微混淆的 Expect 头会暴露大量新的目标。例如，”Expect: y 100-continue” 会在 h1.sec.gitlab.net 上导致 0.CL 同步问题。这是一个有趣的目标，因为它保存了发送给 Gitlab 漏洞赏金计划的报告附件，可能包含关键的零日漏洞。</p>
<p>该网站的攻击面非常小，所以我们无法找到用于利用的经典重定向或 XSS 不同步工具。相反，我们选择尝试响应队列投毒（RQP）——一种高影响的攻击，会导致服务器向每个人发送原本应发送给其他用户的随机响应。由于固有的竞争条件，RQP 在低流量目标上比较棘手，但我们坚持不懈，经过 27,000 次请求后，我们成功访问了别人的漏洞报告视频，并获得了 7,000 美元的赏金：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/30.png" alt="alt text"></p>
<h3 id="CL-0-desync-via-vanilla-Expect-Netlify-CDN"><a href="#CL-0-desync-via-vanilla-Expect-Netlify-CDN" class="headerlink" title="CL.0 desync via vanilla Expect - Netlify CDN"></a>CL.0 desync via vanilla Expect - Netlify CDN</h3><p>证明它可以以各种方式破坏服务器，Expect 还可能导致 CL.0 不同步漏洞。</p>
<p>例如，我们在 Netlify 中发现了一个 CL.0 RQP 漏洞，当触发时，会从 Netlify CDN 上的每个网站向我们发送连续的响应流：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/31.png" alt="alt text"></p>
<p>我们在测试某个由 Netlify 托管的网站时发现了这个问题，但向他们报告似乎没有意义，因为我们截获的响应全部来自第三方网站。该攻击在我们发现后不久就停止了，但我们还是向 Netlify 报告了此事，并收到回复“使用 Netlify 的网站不在范围内”，没有获得任何奖金。通常，当我遇到令人意外的奖金结果时，我不会提及它，因为这往往会分散读者对技术内容的注意力。我在这里破例提出来，是因为它为接下来发生的事情提供了有用的背景。</p>
<h3 id="CL-0-desync-via-obfuscated-Expect-Akamai-CDN"><a href="#CL-0-desync-via-obfuscated-Expect-Akamai-CDN" class="headerlink" title="CL.0 desync via obfuscated Expect - Akamai CDN"></a>CL.0 desync via obfuscated Expect - Akamai CDN</h3><p>不足为奇的是，对 Expect 头进行混淆揭示了更多的 CL.0 同步错误漏洞。这里有一个我们发现的示例，它允许我们向访问 auth.lastpass.com 的用户提供任意内容，从而获得他们的最高奖金——5,000 美元：</p>
<p><img src="/2025/12/23/BH25-USA-HTTP1-1-Must-Die/32.png" alt="alt text"></p>
<p>我们很快意识到，这影响了大量使用 Akamai CDN 的目标。实际上，我相信我们本可以利用它来控制互联网上可能最著名的域名 example.com！不幸的是，example.com 没有漏洞披露计划（VDP），所以验证这一点将是违法的。除非 Akamai 通知我们，否则我们可能永远都不会确定。</p>
<p>尽管如此，这仍然引出了一个问题。我们应该直接将问题报告给受影响的公司，还是报告给 Akamai 呢？作为一名研究人员，维护与双方 CDN 及其客户的良好关系非常重要，而且我赚取的任何赏金都会捐给慈善机构，所以我没有个人利益。然而，我可以看到那些赏金猎人会在没有我帮助的情况下独立发现这个问题，我也不想破坏他们的收入。最终，我决定退后一步——我没有参与探索或报告这个问题，也没有分得赏金。我心里有点遗憾，因为最终这导致了 74 个单独的赏金，总计 221,000 美元。</p>
<p>报告受到了好评，但事情并不完全顺利。事实证明，该漏洞实际上完全存在于 Akamai 的基础设施中，因此 Akamai 收到了大量客户提交的支持工单。我开始担心在 Akamai 仍然易受攻击时该技术可能会泄露，因此联系了 Akamai，帮助他们更快修复问题。该问题被分配了 CVE-2025-32094，我获得了 9,000 美元的奖金。他们能够迅速为部分客户发布热修复，但从那时起到完全解决漏洞仍然用了 65 天。</p>
<p>总的来说，这段经历相当紧张，但至少我得到了部分以美元计价的关于 HTTP&#x2F;1.1 所带来的风险的证据。截至目前，这项研究获得的总奖金大约为 276,000 美元。</p>
<h2 id="Defending-against-HTTP-desync-attacks"><a href="#Defending-against-HTTP-desync-attacks" class="headerlink" title="Defending against HTTP desync attacks"></a>Defending against HTTP desync attacks</h2><h3 id="Why-patching-HTTP-1-1-is-not-enough"><a href="#Why-patching-HTTP-1-1-is-not-enough" class="headerlink" title="Why patching HTTP&#x2F;1.1 is not enough"></a>Why patching HTTP&#x2F;1.1 is not enough</h3><p>本文中的所有攻击都是利用实现上的缺陷，因此得出解决方法是放弃整个协议可能显得有些奇怪。然而，所有这些攻击都有相同的根本原因。HTTP&#x2F;1.1 的致命缺陷——请求分隔不良——意味着微小的错误往往会产生严重影响。这还受到两个关键因素的加剧。</p>
<p>首先，HTTP&#x2F;1.1 只有在不使用代理的情况下才简单。RFC 中包含许多陷阱，比如指定消息长度的三种不同方式、像 Expect 和 Connection 这样的复杂问题，以及像 HEAD 这样的特殊情况。这些都会相互影响，加上解析器的差异，造成无数关键漏洞。</p>
<p>其次，过去六年已经证明，我们在应用能够真正解决威胁的补丁和加固措施方面存在困难。在前端服务器上应用强有力的验证或规范化可以有所帮助，但我们太害怕破坏与旧客户端的兼容性，因此不敢这样做。相反，我们依赖基于正则表达式的防御，而攻击者很容易绕过这些防御。</p>
<p>所有这些因素结合在一起意味着一件事——更多的不同步攻击即将到来。</p>
<h3 id="How-secure-is-HTTP-2-compared-to-HTTP-1"><a href="#How-secure-is-HTTP-2-compared-to-HTTP-1" class="headerlink" title="How secure is HTTP&#x2F;2 compared to HTTP&#x2F;1?"></a>How secure is HTTP&#x2F;2 compared to HTTP&#x2F;1?</h3><p>HTTP&#x2F;2 并不完美——它比 HTTP&#x2F;1 复杂得多，实施起来可能很痛苦。然而，上游的 HTTP&#x2F;2+ 使得不同步漏洞的可能性大大降低。这是因为 HTTP&#x2F;2 是一种二进制协议，非常类似于 TCP 和 TLS，对于每条消息的长度没有任何歧义。你可以预期会有实现上的漏洞，但某个漏洞实际可被利用的概率则显著降低。</p>
<p>到目前为止，在 HTTP&#x2F;2 实现中发现的大多数漏洞都是拒绝服务（DoS）漏洞，例如 <a target="_blank" rel="noopener" href="https://blog.cloudflare.com/technical-breakdown-http2-rapid-reset-ddos-attack/">HTTP&#x2F;2 Rapid Reset</a>——这是 HTTP&#x2F;1 也常见的一类攻击。对于更严重的漏洞，通常需要内存安全问题或整数溢出作为根本原因。同样，这些问题也会影响 HTTP&#x2F;1.1 的实现。当然，总有例外，比如 <a target="_blank" rel="noopener" href="https://nvd.nist.gov/vuln/detail/cve-2023-32731">CVE-2023-32731</a> 和 <a target="_blank" rel="noopener" href="https://portswigger.net/research/http-3-connection-contamination">HTTP&#x2F;3 连接污染</a>——我也期待未来有更多针对这些问题的研究。</p>
<p>请注意，HTTP&#x2F;2 降级，即前端服务器与客户端使用 HTTP&#x2F;2 进行通信，但将其重写为 HTTP&#x2F;1.1 与上游通信，几乎没有安全收益，实际上会使网站更容易受到不同步攻击的影响。</p>
<p>你可能会遇到这样的论点：HTTP&#x2F;1.1 比 HTTP&#x2F;2 更安全，因为 HTTP&#x2F;1.1 的实现更老，因此更加稳固。为反驳这一点，我想将请求走私与缓冲区溢出作一比较。请求走私作为一个知名威胁大约已经存在六年了。这意味着我们针对它的防御手段，其成熟度大约相当于我们在2002年针对缓冲区溢出的防御水平。是时候转向一种内存安全的语言了。</p>
<h3 id="How-to-defeat-request-smuggling-with-HTTP-2"><a href="#How-to-defeat-request-smuggling-with-HTTP-2" class="headerlink" title="How to defeat request smuggling with HTTP&#x2F;2"></a>How to defeat request smuggling with HTTP&#x2F;2</h3><p>首先，确保您的源服务器支持 HTTP&#x2F;2。大多数现代服务器都支持，所以这通常不成问题。</p>
<p>接下来，在你的代理上切换上游 HTTP&#x2F;2。我已经确认以下供应商可以做到这一点：HAProxy、F5 Big-IP、Google Cloud、Imperva、Apache（实验性）和 Cloudflare（但它们内部使用 HTTP&#x2F;1）。</p>
<p>不幸的是，以下供应商尚未增加对上游 HTTP&#x2F;2 的支持：nginx、Akamai、CloudFront、Fastly。可以尝试提交支持请求，询问他们何时会启用上游 HTTP&#x2F;2——希望他们至少能提供一个时间表。同时，查看他们的文档，看看是否可以启用请求规范化——有时一些有价值的缓解措施是可用的，但默认情况下被禁用。</p>
<p>请注意，不需要在浏览器和前端之间禁用 HTTP&#x2F;1。这些连接很少在不同用户之间共享，因此风险明显较小。只需确保它们在上游被转换为 HTTP&#x2F;2 即可。</p>
<h3 id="How-to-survive-with-HTTP-1-1"><a href="#How-to-survive-with-HTTP-1-1" class="headerlink" title="How to survive with HTTP&#x2F;1.1"></a>How to survive with HTTP&#x2F;1.1</h3><p>如果你目前还受制于上游的 HTTP&#x2F;1.1，你可以采用一些策略来帮助你的网站在不可避免的未来同步攻击中生存下来，直到你可以开始使用 HTTP&#x2F;2。</p>
<ul>
<li>在前端服务器上启用所有可用的规范化和验证选项</li>
<li>在后端服务器上启用验证选项</li>
<li>避免使用小众的网页服务器——Apache 和 nginx 风险较低</li>
<li>使用 HTTP 请求走私器定期扫描</li>
<li>禁用上游连接重用（可能会影响性能）</li>
<li>如果方法不需要请求体（GET&#x2F;HEAD&#x2F;OPTIONS），则拒绝包含请求体的请求</li>
</ul>
<p>最后，请注意供应商声称 WAF 可以像上游 HTTP&#x2F;2 一样有效防止不同步攻击的说法。</p>
<h3 id="How-you-can-help-kill-HTTP-1-1"><a href="#How-you-can-help-kill-HTTP-1-1" class="headerlink" title="How you can help kill HTTP&#x2F;1.1"></a>How you can help kill HTTP&#x2F;1.1</h3><p>目前，阻碍淘汰上游 HTTP&#x2F;1 的最大障碍是人们对其危险性的认识不足。希望这项研究能有所帮助，但为了产生持久的影响，并确保六年后我们不会处于同样的境地，我需要你的帮助。</p>
<p>我们需要共同向世界展示 HTTP&#x2F;1.1 的脆弱性。试试 HTTP Request Smuggler 3.0，攻入系统并用 HTTP&#x2F;2 修补它们。尽可能地发布你的发现，让其他人也能从中学习。不要让目标因为方法被修补而轻易逃脱——适应并定制技术和工具，永远不要满足于现状。这并不像你想的那么难，也绝对不需要多年研究经验。例如，在整理这项研究的过程中，我意识到去年发表的一篇写作实际上描述了<a target="_blank" rel="noopener" href="https://mattermost.com/blog/a-dos-bug-thats-worse-than-it-seems/">基于 Expect 的 0.CL desync</a>，所以如果你阅读并应用它，你早就能发现这些成果了！</p>
<p>最后，分享这个信息——更多的不同步攻击总是会到来。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在过去的6年中，我们看到HTTP&#x2F;1.1中的一个设计缺陷经常使网站遭受严重的攻击。试图修补个别实现的尝试未能跟上威胁的步伐，唯一可行的长期解决方案是上游HTTP&#x2F;2。这并不是一蹴而就的事情，但只要意识到上游HTTP&#x2F;1.1到底有多危险，我们就可以帮助扼杀HTTP&#x2F;1.1。</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sakuraraindrop.github.io">cheng_xing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sakuraraindrop.github.io/2025/12/23/BH25-USA-HTTP1-1-Must-Die/">https://sakuraraindrop.github.io/2025/12/23/BH25-USA-HTTP1-1-Must-Die/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://sakuraraindrop.github.io" target="_blank">cheng_xing's blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/ltx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/ltx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">cheng_xing</div><div class="author-info-description">web菜鸡修炼中</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">163</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sakuraraindrop"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/sakuraraindrop" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://space.bilibili.com/504596197" target="_blank" title="Bilibili"><i class="fab fa-bilibili" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract"><span class="toc-number">1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-desync-endgame"><span class="toc-number">2.</span> <span class="toc-text">The desync endgame</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-fatal-flaw-in-HTTP-1-1"><span class="toc-number">2.1.</span> <span class="toc-text">The fatal flaw in HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mitigations-that-hide-but-don%E2%80%99t-fix"><span class="toc-number">2.2.</span> <span class="toc-text">Mitigations that hide but don’t fix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hacking-20-million-websites-by-accident"><span class="toc-number">2.3.</span> <span class="toc-text">Hacking 20 million websites by accident</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9CHTTP-1-is-simple%E2%80%9D-and-other-lies"><span class="toc-number">2.4.</span> <span class="toc-text">“HTTP&#x2F;1 is simple” and other lies</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-strategy-to-win-the-desync-endgame"><span class="toc-number">3.</span> <span class="toc-text">A strategy to win the desync endgame</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Detecting-parser-discrepancies"><span class="toc-number">3.1.</span> <span class="toc-text">Detecting parser discrepancies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Understanding-V-H-and-H-V-discrepancies"><span class="toc-number">3.2.</span> <span class="toc-text">Understanding V-H and H-V discrepancies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Turning-a-V-H-discrepancy-into-a-CL-0-desync"><span class="toc-number">3.3.</span> <span class="toc-text">Turning a V-H discrepancy into a CL.0 desync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Detection-strategies"><span class="toc-number">3.4.</span> <span class="toc-text">Detection strategies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Detecting-high-risk-parsing"><span class="toc-number">3.5.</span> <span class="toc-text">Detecting high-risk parsing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploiting-H-V-on-IIS-behind-ALB"><span class="toc-number">3.6.</span> <span class="toc-text">Exploiting H-V on IIS behind ALB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploiting-H-V-without-Transfer-Encoding"><span class="toc-number">3.7.</span> <span class="toc-text">Exploiting H-V without Transfer-Encoding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-CL-desync-attacks"><span class="toc-number">4.</span> <span class="toc-text">0.CL desync attacks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-0-CL-deadlock"><span class="toc-number">4.1.</span> <span class="toc-text">The 0.CL deadlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Breaking-the-0-CL-deadlock"><span class="toc-number">4.2.</span> <span class="toc-text">Breaking the 0.CL deadlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Moving-beyond-400-Bad-Request"><span class="toc-number">4.3.</span> <span class="toc-text">Moving beyond 400 Bad Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Converting-0-CL-into-CL-0-with-a-double-desync"><span class="toc-number">4.4.</span> <span class="toc-text">Converting 0.CL into CL.0 with a double-desync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#More-desync-attacks-are-coming"><span class="toc-number">4.5.</span> <span class="toc-text">More desync attacks are coming</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Expect-based-desync-attacks"><span class="toc-number">5.</span> <span class="toc-text">Expect-based desync attacks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Expect-complexity-bomb"><span class="toc-number">5.1.</span> <span class="toc-text">The Expect complexity bomb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bypassing-response-header-removal"><span class="toc-number">5.2.</span> <span class="toc-text">Bypassing response header removal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#An-unplanned-collaboration"><span class="toc-number">5.3.</span> <span class="toc-text">An unplanned collaboration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-CL-desync-via-vanilla-Expect-T-Mobile"><span class="toc-number">5.4.</span> <span class="toc-text">0.CL desync via vanilla Expect - T-Mobile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-CL-desync-via-obfuscated-Expect-Gitlab"><span class="toc-number">5.5.</span> <span class="toc-text">0.CL desync via obfuscated Expect - Gitlab</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CL-0-desync-via-vanilla-Expect-Netlify-CDN"><span class="toc-number">5.6.</span> <span class="toc-text">CL.0 desync via vanilla Expect - Netlify CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CL-0-desync-via-obfuscated-Expect-Akamai-CDN"><span class="toc-number">5.7.</span> <span class="toc-text">CL.0 desync via obfuscated Expect - Akamai CDN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Defending-against-HTTP-desync-attacks"><span class="toc-number">6.</span> <span class="toc-text">Defending against HTTP desync attacks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-patching-HTTP-1-1-is-not-enough"><span class="toc-number">6.1.</span> <span class="toc-text">Why patching HTTP&#x2F;1.1 is not enough</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-secure-is-HTTP-2-compared-to-HTTP-1"><span class="toc-number">6.2.</span> <span class="toc-text">How secure is HTTP&#x2F;2 compared to HTTP&#x2F;1?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-defeat-request-smuggling-with-HTTP-2"><span class="toc-number">6.3.</span> <span class="toc-text">How to defeat request smuggling with HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-survive-with-HTTP-1-1"><span class="toc-number">6.4.</span> <span class="toc-text">How to survive with HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-you-can-help-kill-HTTP-1-1"><span class="toc-number">6.5.</span> <span class="toc-text">How you can help kill HTTP&#x2F;1.1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">7.</span> <span class="toc-text">Conclusion</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/02/20251202%E9%9A%8F%E7%BC%98%E5%88%B7%E9%A2%98/" title="20251202随缘刷题">20251202随缘刷题</a><time datetime="2025-12-01T16:26:54.000Z" title="发表于 2025-12-02 00:26:54">2025-12-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/01/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/" title="原型链污染">原型链污染</a><time datetime="2025-12-01T01:54:55.000Z" title="发表于 2025-12-01 09:54:55">2025-12-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/28/20251128%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/" title="20251128论文学习">20251128论文学习</a><time datetime="2025-11-28T02:24:00.000Z" title="发表于 2025-11-28 10:24:00">2025-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/05/0xGame2025/" title="0xGame2025">0xGame2025</a><time datetime="2025-11-05T10:51:18.000Z" title="发表于 2025-11-05 18:51:18">2025-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/04/%E5%BC%BA%E7%BD%91%E6%9D%AFS9-web/" title="强网杯S9-web">强网杯S9-web</a><time datetime="2025-11-04T06:24:51.000Z" title="发表于 2025-11-04 14:24:51">2025-11-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/hk.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By cheng_xing</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>